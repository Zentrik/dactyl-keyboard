(ns dactyl-keyboard.cad.tweak-test
  (:require [clojure.set :as setlib]
            [clojure.test :refer [deftest testing is]]
            [dactyl-keyboard.fixture :refer [unit-testing-accessor]]
            [dactyl-keyboard.param.proc.anch :as anch]
            [dactyl-keyboard.cad.tweak :refer [select]]))

;;; This module uses a consistent mock getopt function to try out various tweak
;;; selection criteria.

(def key->digest
  "Semi-realistic nodes, named using keyword arguments for local purposes."
  (reduce
    (fn [coll [k v]]
      "Refine mock inputs by looking up leaves."
      (let [children (:hull-around v)]
        (assoc coll k
          (if children
            (update v :hull-around (partial mapv coll))
            v))))
    {}
    ;; Leaf a is anchored to the origin which, in the absence of a central
    ;; housing, is part of the main body.
    {:l-a {:above-ground true
           :anchoring {:anchor :origin}}
    ;; Leaf b is anchored a little more directly to the central housing.
     :l-b {:anchoring {:anchor :c1}}
    ;; Branch nodes follow.
     :b-a {:above-ground true
           :body :central-housing
           :hull-around [:l-a]}
     :b-b {:cut true
           :to-ground true
           :at-ground false
           :hull-around [:l-a]}
     :b-c0 {:shadow-ground true
            :hull-around [:l-b]}
     :b-c1 {:above-ground true
            :polyfill true
            :body :central-housing
            :hull-around [:l-a]}}))
(def digest->key (setlib/map-invert key->digest))

(def getopt
  "Fake the data structure normally generated by refining a configuration."
  (unit-testing-accessor
   {:main-body {:reflect false}  ; Disable central housing, part 1.
    :central-housing {:include false}  ; Disable central housing, part 2.
    :derived {:anchors {:origin {::anch/type ::anch/origin}
                        :c1 {::anch/type ::anch/central-gabel}}}
    :tweaks
      (let [k key->digest]
        {:a [(k :l-a) (k :b-a)]
         :b [(k :b-b)]
         :c [(k :b-c0) (k :b-c1)]})}))

(defn- vary-body
  "Apply a set of criteria varied by the target set of bodies.
  Require that the return value for the main and central housing bodies is the
  union of the return value for each body on its own. Discard that union and
  return the smaller values separately."
  [criteria]
  (let [[x y z] (mapv #(select getopt (merge criteria {:bodies %}))
                       [#{:main} #{:central-housing} #{:main :central-housing}])
        back (fn [ds] (mapv #(get digest->key %) ds))]
    (assert (= (setlib/union (set x) (set y)) (set z)))
    (mapv back [x y])))

(deftest screening
  (testing "no criteria"
    (is (thrown? java.lang.AssertionError
          (select getopt {}))))
  (testing "body only"
    (is (= (vary-body {})
           [[] []])))
  (testing "actively nothing"
    (is (= (vary-body {:include-negative false
                       :include-positive false
                       :include-bottom false
                       :include-top false})
           [[] []])))
  (testing "neither positive nor negative"
    (is (= (vary-body {:include-negative false
                       :include-positive false
                       :include-bottom true
                       :include-top true})
           [[] []])))
  (testing "inclusively positive"
    (is (= (vary-body {:include-positive true
                       ; No criterion for negatives.
                       :include-bottom true
                       :include-top true})
           [[:l-a] [:b-a :b-c0 :b-c1]])))
  (testing "inclusively not positive"
    (is (= (vary-body {:include-positive false
                       ; No criterion for negatives -> no hits.
                       :include-bottom true
                       :include-top true})
           [[] []])))
  (testing "exclusively not positive"
    (is (= (vary-body {:include-positive false
                       :include-negative true
                       :include-bottom true
                       :include-top true})
           [[:b-b] []])))
  (testing "inclusively negative"
    (is (= (vary-body {:include-negative true
                       :include-bottom true
                       :include-top true})
           [[:b-b] []])))
  (testing "not at any level"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom false
                       :include-top false})
           [[] []])))
  (testing "inclusively at ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom true})
           [[] [:b-c0 :b-c1]])))
  (testing "exclusively at ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom true
                       :include-top false})
           [[] [:b-c0]])))
  (testing "inclusively not at ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom false})
           [[] []])))
  (testing "inclusively above ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-top true})
           [[:l-a :b-b] [:b-a :b-c1]])))
  (testing "exclusively above ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom false
                       :include-top true})
           [[:l-a :b-b] [:b-a]])))
  (testing "inclusively not above ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-top false})
           [[] []])))
  (testing "polyfilled without other at ground"
    (is (= (vary-body {:include-positive true
                       :include-negative true
                       :polyfilled-at-ground true})
           [[] [:b-c1]])))
  (testing "projected without other at ground"
    (is (= (vary-body {:include-positive true
                       :include-negative true
                       :projected-at-ground true})
           [[] [:b-c0]])))
  (testing "everything"
    (is (= (vary-body {:include-positive true
                       :include-negative true
                       :include-bottom true
                       :include-top true})
           [[:l-a :b-b] [:b-a :b-c0 :b-c1]]))))
