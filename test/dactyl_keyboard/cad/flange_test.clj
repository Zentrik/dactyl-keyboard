(ns dactyl-keyboard.cad.flange-test
  (:require [clojure.set :as setlib]
            [clojure.test :refer [deftest testing is]]
            [dactyl-keyboard.fixture :refer [unit-testing-accessor]]
            [dactyl-keyboard.param.proc.anch :as anch]
            [dactyl-keyboard.cad.flange :refer [select]]))

;;; This module uses a consistent mock getopt function to try out various
;;; flange selection criteria.

(def getopt
  "Fake the data structure normally generated by refining a configuration."
  (unit-testing-accessor
   {:main-body {:reflect true
                :bottom-plate {:include true}}
    :central-housing {:include false}
    :derived {:anchors {:origin {::anch/type ::anch/origin}
                        :c1 {::anch/type ::anch/central-gabel}}}
    :flanges
      (let [defaults {:include true
                      :body :auto
                      :bottom false
                      :bosses {:include false}
                      :inserts {:include false}
                      :bolts {:include false}
                      :positions [{:anchoring {:anchor :origin}}]}]
        {:a (-> defaults
              (assoc-in [:bosses :include] true))
         :b (-> defaults
              (assoc-in [:inserts :include] true)
              (update-in [:positions] #(conj % {:anchoring {:anchor :c1}})))
         :c (-> defaults
              (assoc-in [:body] :main)  ; Ignore natural body of position at :c1.
              (assoc-in [:bolts :include] true)
              (update-in [:positions] #(conj % {:anchoring {:anchor :c1}})))
         :d (-> defaults
              (assoc-in [:bolts :include] true)
              (assoc-in [:body] :wrist-rest))
         :e (-> defaults
              (assoc-in [:bottom] true)
              (assoc-in [:bosses :include] true)
              (assoc-in [:bolts :include] true)
              (assoc-in [:positions 0 :anchoring :anchor] :c1))})}))

(defn- vary-body
  "Apply a set of criteria varied by the target set of bodies.
  Require that the return value for the main and central housing bodies is the
  union of the return value for each body on its own. Discard that union and
  return the smaller values separately."
  ; Notice that :wrist-rest is never selected, therefore flange :d should never
  ; appear.
  [criteria]
  (let [[x y z] (mapv #(select getopt (merge criteria {:bodies %}))
                       [#{:main} #{:central-housing} #{:main :central-housing}])]
    (assert (= (setlib/union (set x) (set y)) (set z)))
    [x y]))

(deftest screening
  (testing "no criteria"
    (is (thrown? java.lang.AssertionError
          (select getopt {}))))
  (testing "body only"
    (is (= (vary-body {})
           ['() '()])))
  (testing "actively nothing"
    (is (= (vary-body {:include-negative false
                       :include-positive false
                       :include-bottom false
                       :include-top false})
           ['() '()])))
  (testing "neither positive nor negative"
    (is (= (vary-body {:include-negative false
                       :include-positive false
                       :include-bottom true
                       :include-top true})
           ['() '()])))
  (testing "inclusively positive"
    (is (= (vary-body {:include-positive true
                       ; No criterion for negatives.
                       :include-bottom true
                       :include-top true})
           ['([:a 0]) '([:e 0])])))
  (testing "inclusively not positive"
    (is (= (vary-body {:include-positive false
                       ; No criterion for negatives -> no hits.
                       :include-bottom true
                       :include-top true})
           ['() '()])))
  (testing "exclusively not positive"
    (is (= (vary-body {:include-positive false
                       :include-negative true
                       :include-bottom true
                       :include-top true})
           ['([:b 0] [:c 0] [:c 1]) '([:b 1] [:e 0])])))
  (testing "inclusively negative"
    (is (= (vary-body {:include-negative true
                       :include-bottom true
                       :include-top true})
           ['([:b 0] [:c 0] [:c 1]) '([:b 1] [:e 0])])))
  (testing "not at any level"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom false
                       :include-top false})
           ['() '()])))
  (testing "inclusively at ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom true})
           ['() '([:e 0])])))
  (testing "exclusively at ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom true
                       :include-top false})
           ['() '([:e 0])])))
  (testing "inclusively not at ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom false})
           ['() '()])))
  (testing "inclusively above ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-top true})
           ['([:a 0] [:b 0] [:c 0] [:c 1]) '([:b 1] [:e 0])])))
  (testing "exclusively above ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-bottom false
                       :include-top true})
           ['([:a 0] [:b 0] [:c 0] [:c 1]) '([:b 1] [:e 0])])))
  (testing "inclusively not above ground"
    (is (= (vary-body {:include-negative true
                       :include-positive true
                       :include-top false})
           ['() '()])))
  (testing "everything but the wrist rest"
    (is (= (vary-body {:include-positive true
                       :include-negative true
                       :include-bottom true
                       :include-top true})
           ['([:a 0] [:b 0] [:c 0] [:c 1]) '([:b 1] [:e 0])]))))
